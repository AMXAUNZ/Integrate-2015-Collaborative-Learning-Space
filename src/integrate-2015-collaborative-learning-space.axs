PROGRAM_NAME='integrate-2015-collaborative-learning-space'

/**
AMX Australia
Integrate 2015
Collaborative Learning Space

GitHub Repository:
	https://github.com/AMXAUNZ/Integrate-2015-Collaborative-Learning-Space

Programmed by:
	David Vine
	AMX Australia
	david.vine@amxaustralia.com.au

This is the NetLinx program running in the Collaborative Learning Space demo
at the Integrate 2015 trade show in Melbourne, Australia.

The demo shows off a number of different technologies available from AMX which
can work together to provide a holistic solution for a learning environment.

The code in this project is broken up into numerous files to avoid having one
massive code file with thousands of lines of code.

Pre-built library's have been created for a number of AMX products and these
are heavily used by this project. Each library is split into 3 x include files:
	API
	Control
	Listener

The API include file contains various constants relating to the channel codes,
level codes, ports, command headers, and command parameters which make up the 
API of that device.

The Control include file contains function subroutines for every aspect of 
control that the device can perform including requesting information from the 
device.

The Listener include file handles events generated by the device and calls 
specific function subroutines depending on what type of event is generated and 
what type of information that event contains. These subroutines are defined 
within the Listener include file but are commented out with the expectation 
that the programmer will copy the functions relating to information they want 
to listen for. Compiler directives are used to only compile sections of the 
code which are required thereby reducing the overall size of the compiled file. 
Because compiler directives are utilised it is very important that the Listener 
include file be included at the bottom of the main program code file (last). 
Otherwise, the functions copied by the programmer will not get executed or 
compiler errors could result.

The 3 x library includes (API, Control, and Listener) allow the programmer to 
use functions for everything and easy to remember constant identifiers. They 
also provide a way of minimizing the need to convert back and forth between 
different data types as data type conversion is all taken care of. Lastly. 
the use of functions which can be called to control the device or request 
information removes the complexity of building complex NetLinx commands.

There is even a pre-written Include file (device-control.axi) which allows the 
programmer to use functions for the most basic of NetLinx operations such as 
the sendCommand function which can be used in place of the SEND_COMMAND keyword.

The NetLinx programming language syntax can sometimes be difficult to remember
for beginners:
 E.g. #1	ON[device,channel]
 E.g. #2	SEND_STRING device, 'text'
 E.g. #3	SEND_COMMAND device, "'text',string,'text',ITOA(value)"
 E.g. #4	DATA_EVENT[device]
These re-written Includes have been created to create a more uniform way of 
programming a NetLinx system ... EVERYTHING is a function!
**/

// Compliler Directive Definitions
#include 'system-defines'

// Include Files (non-library)
#include 'system-includes'

// Include Files for Library API's
#include 'system-library-api'

// Include Files for Library Control Subroutines
#include 'system-library-control'

// System Constants
#include 'system-constants'

// Device Declarations
#include 'system-devices'

// Custom Defined Data Types (structures)
#include 'system-structures'

// Global Variables
#include 'system-variables'

// Mutually Exclusive Groups
#include 'system-mutual-exclusions'

// Function Subroutines
#include 'system-functions'

// Module Declarations
#include 'system-modules'

// Power-up Initialisation
#include 'system-start'

// Event Handling
#include 'system-events'

// Include Files for Library Listener Event Handling and Soubroutine Calling
#include 'system-library-listener'

// Mainline
#include 'system-mainline'
